package graphlayout;

import java.awt.Font;
import java.io.File;
import java.io.InputStream;
import java.io.FileInputStream;
import java.io.IOException;
import java.util.Properties;

import org.gephi.graph.api.DirectedGraph;
import org.gephi.graph.api.GraphController;
import org.gephi.graph.api.GraphModel;
import org.gephi.graph.api.GraphView;
import org.gephi.io.exporter.api.ExportController;
import org.gephi.io.importer.api.Container;
import org.gephi.io.importer.api.EdgeDefault;
import org.gephi.io.importer.api.ImportController;
import org.gephi.io.processor.plugin.DefaultProcessor;
import org.gephi.layout.plugin.forceAtlas2.ForceAtlas2;
import org.gephi.layout.plugin.forceAtlas2.ForceAtlas2Builder;
import org.gephi.ranking.api.Ranking;
import org.gephi.ranking.api.RankingController;
import org.gephi.ranking.api.Transformer;
import org.gephi.project.api.ProjectController;
import org.gephi.project.api.Workspace;
import org.gephi.preview.api.PreviewController;
import org.gephi.preview.api.PreviewModel;
import org.gephi.preview.api.PreviewProperty;
import org.gephi.preview.types.EdgeColor;
import org.gephi.datalab.api.AttributeColumnsController;
import org.gephi.dynamic.api.DynamicController;
import org.gephi.data.attributes.api.AttributeType;
import org.gephi.data.attributes.api.AttributeColumn;
import org.gephi.data.attributes.api.AttributeController;
import org.gephi.data.attributes.api.AttributeModel;
import org.gephi.layout.plugin.force.StepDisplacement;
import org.gephi.layout.plugin.force.yifanHu.YifanHuLayout;
import org.gephi.layout.plugin.labelAdjust.LabelAdjust;

import org.openide.util.Lookup;
import java.nio.charset.Charset;

// Filtering imports
import org.gephi.filters.api.FilterController;
import org.gephi.filters.api.Query;
import org.gephi.filters.api.Range;
import org.gephi.filters.plugin.graph.DegreeRangeBuilder.DegreeRangeFilter;

// Degree and centrality ranking imports
import org.gephi.ranking.api.Ranking;
import org.gephi.ranking.api.RankingController;
import org.gephi.ranking.api.Transformer;

// Color mapping imports
import java.awt.Color;
import org.gephi.ranking.plugin.transformer.AbstractColorTransformer;
import org.gephi.ranking.plugin.transformer.AbstractSizeTransformer;
import org.gephi.statistics.plugin.GraphDistance;

// Partioning (clustering) imports
import org.gephi.io.processor.plugin.DefaultProcessor;
import org.gephi.partition.api.Partition;
import org.gephi.partition.api.PartitionController;
import org.gephi.partition.plugin.NodeColorTransformer;
import org.gephi.statistics.plugin.Modularity;

/**
 * This class is a complete chain visualization, from data import to result export.
 *
 * Reads user-specified visualization options from ../net-langs/analysis/visualize/temp.properties,
 * which is derived from ../net-langs/analysis/settings.py
 *
 */

public class Main {

    // Layout constants:
    private static final int LAYOUT_ITERATIONS = 20000;
    private static final Integer THREADS_COUNT = 8;
    private static final Double LAYOUT_SCALE = 100.0;
    private static final Boolean BARNES_HUTT_OPTIMIZE = true;
    private static final Boolean ADJUST_SIZES = true;

    public static void main(String[] args) throws InterruptedException {
        System.out.println("\n\tRunning Gephi Toolkit");
        long start_time = System.currentTimeMillis();

        // Init a project - and therefore a workspace
        ProjectController pc = Lookup.getDefault().lookup(ProjectController.class);
        pc.newProject();

        Workspace workspace = pc.getCurrentWorkspace();

        // Get models and controllers for this new workspace - will be useful later
        GraphModel graphModel = Lookup.getDefault().lookup(GraphController.class).getModel();
        PreviewModel model = Lookup.getDefault().lookup(PreviewController.class).getModel();
	AttributeModel attributeModel = Lookup.getDefault().lookup(AttributeController.class).getModel();
	AttributeColumnsController ac = Lookup.getDefault().lookup(AttributeColumnsController.class);
        ImportController importController = Lookup.getDefault().lookup(ImportController.class);
        RankingController rankingController = Lookup.getDefault().lookup(RankingController.class);
        FilterController filterController = Lookup.getDefault().lookup(FilterController.class);

        //Import file
        Container container;

	// Input network
        try {
            // Temporary files generated by visualize.create_temp_files()
            File nodeFile = new File("temp_node.tsv");
            File edgeFile = new File("temp_edge.tsv");

	    char separator = '\t';
            AttributeType att = null;
            Charset myCharset = Charset.forName("UTF-8");

            String nodeColumnNames [] = {"Id", "Label", "Num_Speakers"};
            AttributeType nodeColumnTypes [] = {att.STRING, att.STRING, att.FLOAT};

            String edgeColumnNames [] = {"Source", "Target", "Weight"};
            AttributeType edgeColumnTypes [] = {att.STRING, att.STRING, att.FLOAT};

	    // Import to node and edge tables
            ac.importCSVToNodesTable(nodeFile, separator, myCharset, nodeColumnNames, nodeColumnTypes, true);
            ac.importCSVToEdgesTable(edgeFile, separator, myCharset, edgeColumnNames, edgeColumnTypes, false);


        } catch (Exception ex) {
            ex.printStackTrace();
            return;
        }

        //See if graph is well imported
        DirectedGraph graph = graphModel.getDirectedGraph();
        System.out.println("\t\tImported Nodes: " + graph.getNodeCount());
        System.out.println("\t\tImported Edges: " + graph.getEdgeCount());


        //Filter
        System.out.println("\t\tFiltering nodes");
        DegreeRangeFilter degreeFilter = new DegreeRangeFilter();
        degreeFilter.init(graph);
        degreeFilter.setRange(new Range(1, Integer.MAX_VALUE));     //Remove nodes with degree < 30
        Query query = filterController.createQuery(degreeFilter);
        GraphView view = filterController.filter(query);
        graphModel.setVisibleView(view);    //Set the filter result as the visible view


        //Rank color by Degree
        System.out.println("\t\tRanking color by degree");
        Ranking degreeRanking = rankingController.getModel().getRanking(Ranking.NODE_ELEMENT, Ranking.DEGREE_RANKING);
        AbstractColorTransformer colorTransformer = (AbstractColorTransformer) rankingController.getModel().getTransformer(Ranking.NODE_ELEMENT, Transformer.RENDERABLE_COLOR);

        colorTransformer.setColors(new Color[]{new Color(0xFFFC17), new Color(0xB30000)});
        rankingController.transform(degreeRanking, colorTransformer);


        //Get Centrality
        System.out.println("\t\tCalculating centrality");
        GraphDistance distance = new GraphDistance();
        distance.setDirected(true);
        distance.execute(graphModel, attributeModel);

        // TODO: USE REAL LIFE MEASURES
        // SIZE: HOW MANY PEOPLE IN WORLD SPEAK LANGUAGE
        // THICKNESS/ WEIGHT: WEIGHT
        // COLOR: LANGUAGE FAMILY
        //Rank size by centrality

        // System.out.println("\t\tRanking size by centrality");
        // AttributeColumn centralityColumn = attributeModel.getNodeTable().getColumn(GraphDistance.BETWEENNESS);
        // Ranking centralityRanking = rankingController.getModel().getRanking(Ranking.NODE_ELEMENT, centralityColumn.getId());
        // AbstractSizeTransformer sizeTransformer = (AbstractSizeTransformer) rankingController.getModel().getTransformer(Ranking.NODE_ELEMENT, Transformer.RENDERABLE_SIZE);
        // sizeTransformer.setMinSize(10); // 5 for books, 30 for wiki
        // sizeTransformer.setMaxSize(40);  // 30 for books, 60 for wiki
        // rankingController.transform(centralityRanking,sizeTransformer);

	System.out.println("\t\tAssigning size by number of speakers");
	AttributeColumn numSpeakersColumn = attributeModel.getNodeTable().getColumn("Num_Speakers");
        Ranking speakersRanking = rankingController.getModel().getRanking(Ranking.NODE_ELEMENT, numSpeakersColumn.getId());
        AbstractSizeTransformer sizeTransformer = (AbstractSizeTransformer) rankingController.getModel().getTransformer(Ranking.NODE_ELEMENT, Transformer.RENDERABLE_SIZE);
        sizeTransformer.setMinSize(10); //MIN_NODE_SIZE); // 5 for books, 30 for wiki
        sizeTransformer.setMaxSize(60); // MAX_NODE_SIZE);  // 30 for books, 60 for wiki
        rankingController.transform(speakersRanking, sizeTransformer);

        //Rank label size - set a multiplier size
        System.out.println("\t\tRanking label size");
        Ranking speakersRanking2 = rankingController.getModel().getRanking(Ranking.NODE_ELEMENT, numSpeakersColumn.getId());
        AbstractSizeTransformer labelSizeTransformer = (AbstractSizeTransformer) rankingController.getModel().getTransformer(Ranking.NODE_ELEMENT, Transformer.LABEL_SIZE);
        labelSizeTransformer.setMinSize(1);
        labelSizeTransformer.setMaxSize(3);
        rankingController.transform(speakersRanking2, labelSizeTransformer);

	// System.out.println("\t\tAdjusting edge sizes");
	// AttributeColumn weightColumn = attributeModel.getEdgeTable().getColumn("Weight");
        // Ranking weightRanking = rankingController.getModel().getRanking(Ranking.EDGE_ELEMENT, weightColumn.getId());
        // AbstractSizeTransformer edgeSizeTransformer = (AbstractSizeTransformer) rankingController.getModel().getTransformer(Ranking.EDGE_ELEMENT, Transformer.RENDERABLE_SIZE);
        // edgeSizeTransformer.setMinSize(100); //MIN_NODE_SIZE); // 5 for books, 30 for wiki
        // edgeSizeTransformer.setMaxSize(300); // MAX_NODE_SIZE);  // 30 for books, 60 for wiki
        // rankingController.transform(weightRanking, edgeSizeTransformer);


        //Run Force Atlas 2 layout - The layout always takes the current visible view
        long start_layout_time = System.currentTimeMillis();
        System.out.println("\t\tRunning layout algorithm");
        ForceAtlas2 layout = new ForceAtlas2Builder().buildLayout();
        layout.setGraphModel(graphModel);
        layout.initAlgo();
        layout.resetPropertiesValues();
	// layout.setGravity(0.05);
        layout.setAdjustSizes(ADJUST_SIZES);
        layout.setBarnesHutOptimize(BARNES_HUTT_OPTIMIZE);
        layout.setScalingRatio(LAYOUT_SCALE);
        layout.setThreadsCount(THREADS_COUNT);

        /*
        //Run YifanHuLayout for 100 passes - The layout always takes the current visible view
        YifanHuLayout layout = new YifanHuLayout(null, new StepDisplacement(1f));
        layout.setGraphModel(graphModel);
        layout.resetPropertiesValues();
        layout.setOptimalDistance(200f);
        layout.initAlgo();
        */

        for (int i = 0; i < LAYOUT_ITERATIONS && layout.canAlgo(); i++) {
            layout.goAlgo();
        }
        layout.endAlgo();

        double elapsed_layout_time = (System.currentTimeMillis() - start_layout_time) / 1000.;
        System.out.println("\t\tTime for layout: " + String.valueOf(elapsed_layout_time) + " seconds");

        // Preview
        // Load a nice TTF font (Colaboration Light)
        try {
            File f = new File("ColabLig.ttf");
            FileInputStream in = new FileInputStream(f);
            Font colab_lig = Font.createFont(Font.TRUETYPE_FONT, in);
            Font colab_lig_15pt = colab_lig.deriveFont(15f);
            model.getProperties().putValue(PreviewProperty.NODE_LABEL_FONT, colab_lig_15pt);
        } catch (Exception ex) {
            ex.printStackTrace();
        }

        model.getProperties().putValue(PreviewProperty.SHOW_NODE_LABELS, Boolean.TRUE);
        model.getProperties().putValue(PreviewProperty.EDGE_CURVED, Boolean.FALSE);
        model.getProperties().putValue(PreviewProperty.ARROW_SIZE, 5.0); // 15.0
        model.getProperties().putValue(PreviewProperty.EDGE_COLOR, new EdgeColor(Color.BLACK)); // GRAY));
        model.getProperties().putValue(PreviewProperty.EDGE_OPACITY, 100); // EDGE_OPACITY);
        model.getProperties().putValue(PreviewProperty.NODE_BORDER_WIDTH, 1.0);
        model.getProperties().putValue(PreviewProperty.MARGIN, 15);
        model.getProperties().putValue(PreviewProperty.DIRECTED, Boolean.TRUE);
	// model.getProperties().putValue(PreviewProperty.EDGE_RESCALE_WEIGHT, Boolean.TRUE);
        // model.getProperties().putValue(PreviewProperty.EDGE_THICKNESS, 1.0);

        //Export graph:
        ExportController ec = Lookup.getDefault().lookup(ExportController.class);
        try {
            ec.exportFile(new File("network.gexf"));
            System.out.println("\t\tCreated file network.gexf");
            ec.exportFile(new File("network.pdf"));
            System.out.println("\t\tCreated file network.pdf");
            ec.exportFile(new File("network.png"));
            System.out.println("\t\tCreated file network.png");
            ec.exportFile(new File("network.svg"));
	    System.out.println("\t\tCreated file network.svg");
        } catch (IOException ex) {
            ex.printStackTrace();
        }

        System.out.println("\t\tFinished Visualization");
        double elapsed_time = (System.currentTimeMillis() - start_time) / 1000.;
        System.out.println("\t\tTotal elapsed time: " + String.valueOf(elapsed_time) + " seconds");
        System.exit(0); //Workaround for exit bug
    }
}
